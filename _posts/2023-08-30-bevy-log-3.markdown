## Renet

So to setup renet you need 3 things.

# Adding the plugins
{% highlight rust %}
// Server
    app.add_plugins(RenetServerPlugin);
    app.add_plugins(NetcodeServerPlugin);
// Client
    app.add_plugins(RenetClientPlugin);
    app.add_plugins(NetcodeClientPlugin);
{% endhighlight %}

# The Client and Server Channels
{% highlight rust %}
pub fn connection_config() -> ConnectionConfig {
    ConnectionConfig {
        available_bytes_per_tick: 1024 * 1024,
        client_channels_config: ClientChannel::channels_config(),
        server_channels_config: ServerChannel::channels_config(),
    }
}

pub enum ClientChannel {
    Command,
}

impl From<ClientChannel> for u8 {
    fn from(channel_id: ClientChannel) -> Self {
        match channel_id {
            ClientChannel::Command => 0,
        }
    }
}

impl ClientChannel {
    pub fn channels_config() -> Vec<ChannelConfig> {
        vec![
            ChannelConfig {
                channel_id: Self::Command.into(),
                max_memory_usage_bytes: 5 * 1024 * 1024,
                send_type: SendType::ReliableOrdered {
                    resend_time: Duration::ZERO,
                },
            },
        ]
    }
}

pub enum ServerChannel {
    Spawn,
    Despawn,
    Update,
    Load,
    ServerMessages,
    Tick,
    Test,
    ServerEvents,
}

impl From<ServerChannel> for u8 {
    fn from(channel_id: ServerChannel) -> Self {
        match channel_id {
            ServerChannel::Spawn => 0,
            ServerChannel::Despawn => 1,
            ServerChannel::Update => 2,
            ServerChannel::Load => 3,
            ServerChannel::ServerMessages => 4,
            ServerChannel::Tick => 5,
            ServerChannel::Test => 6,
            ServerChannel::ServerEvents => 7,
        }
    }
}

impl ServerChannel {
    pub fn channels_config() -> Vec<ChannelConfig> {
        vec![
            ChannelConfig {
                channel_id: Self::Spawn.into(),
                max_memory_usage_bytes: 10 * 1024 * 1024,
                send_type: SendType::ReliableUnordered {
                    resend_time: Duration::from_millis(200),
                },
            },
            ChannelConfig {
                channel_id: Self::Despawn.into(),
                max_memory_usage_bytes: 10 * 1024 * 1024,
                send_type: SendType::ReliableUnordered {
                    resend_time: Duration::from_millis(200),
                },
            },
            ChannelConfig {
                channel_id: Self::Update.into(),
                max_memory_usage_bytes: 10 * 1024 * 1024,
                send_type: SendType::ReliableUnordered {
                    resend_time: Duration::from_millis(200),
                },
            },
            ChannelConfig {
                channel_id: Self::Load.into(),
                max_memory_usage_bytes: 10 * 1024 * 1024,
                send_type: SendType::ReliableUnordered {
                    resend_time: Duration::from_millis(200),
                },
            },
            ChannelConfig {
                channel_id: Self::ServerMessages.into(),
                max_memory_usage_bytes: 10 * 1024 * 1024,
                send_type: SendType::ReliableUnordered {
                    resend_time: Duration::from_millis(200),
                },
            },
            ChannelConfig {
                channel_id: Self::Tick.into(),
                max_memory_usage_bytes: 10 * 1024 * 1024,
                send_type: SendType::ReliableOrdered {
                    resend_time: Duration::from_millis(200),
                },
            },
            ChannelConfig {
                channel_id: Self::Test.into(),
                max_memory_usage_bytes: 10 * 1024 * 1024,
                send_type: SendType::ReliableUnordered {
                    resend_time: Duration::from_millis(200),
                },
            },
            ChannelConfig {
                channel_id: Self::ServerEvents.into(),
                max_memory_usage_bytes: 10 * 1024 * 1024,
                send_type: SendType::ReliableUnordered {
                    resend_time: Duration::from_millis(200),
                },
            },
        ]
    }
}

{% endhighlight %}

# a function that gets us the client/server and transport resources
{% highlight rust %}
// Server 
pub fn new_renet_server() -> (RenetServer, NetcodeServerTransport) {
    let server_channels_config = ServerChannel::channels_config();
    let client_channels_config = ClientChannel::channels_config();
    let port = 4000;

    let server = RenetServer::new(ConnectionConfig {
        server_channels_config,
        client_channels_config,
        ..Default::default()
    });

    let current_time = SystemTime::now()
        .duration_since(SystemTime::UNIX_EPOCH)
        .unwrap();
    let public_addr = SocketAddr::new(Ipv4Addr::LOCALHOST.into(), port);
    let socket = UdpSocket::bind(public_addr).unwrap();
    let server_config = ServerConfig {
        max_clients: 5,
        protocol_id: PROTOCOL_ID,
        public_addr,
        authentication: ServerAuthentication::Unsecure,
    };
    let transport = NetcodeServerTransport::new(current_time, server_config, socket).unwrap();
    (server, transport)
}


// Client
pub fn new_renet_client() -> (RenetClient, NetcodeClientTransport) {
    let server_channels_config = ServerChannel::channels_config();
    let client_channels_config = ClientChannel::channels_config();
    let port = 4000;

    let client = RenetClient::new(ConnectionConfig {
        server_channels_config,
        client_channels_config,
        ..Default::default()
    });

    let current_time = SystemTime::now()
        .duration_since(SystemTime::UNIX_EPOCH)
        .unwrap();
    let client_id = current_time.as_millis() as u64;
    let server_addr = SocketAddr::new(Ipv4Addr::LOCALHOST.into(), port);
    let socket = UdpSocket::bind(("127.0.0.1", 0)).unwrap();
    let authentication = ClientAuthentication::Unsecure {
        client_id,
        protocol_id: PROTOCOL_ID,
        server_addr,
        user_data: None,
    };
    let transport = NetcodeClientTransport::new(current_time, authentication, socket).unwrap();
    (client, transport)
}
// inserting the resources
    let (client, transport) = new_renet_client();
    app.insert_resource(client);
    app.insert_resource(transport);
// and
    let (server, transport) = new_renet_server();
    app.insert_resource(server);
    app.insert_resource(transport);


{% endhighlight %}

So now renet is all setup I'll start off by just sending the server tick to the client:
{% highlight rust %}
// fn main
    app.add_systems(FixedUpdate, tick);
    app.add_systems(FixedUpdate, send_tick);
fn tick(mut tick: ResMut<GameTick>) {
    tick.tick += 1;
}

fn send_tick(tick: Res<GameTick>, mut server: ResMut<RenetServer>){
    let message = bincode::serialize(&[tick.tick]).unwrap();
    server.broadcast_message(ServerChannel::Tick, message)

}

// receiving the tick on client
fn receive_tick(mut commands: Commands, mut client: ResMut<RenetClient>) {
    while let Some(message) = client.receive_message(ServerChannel::Tick) {
        let tick: u64 = bincode::deserialize(&message).unwrap();
        commands.insert_resource(GameTick { tick });
    }
}



